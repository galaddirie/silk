---
description:
globs:
alwaysApply: true
---
# Typed Array

```
A typed array module.

This module provides an typed array type TypedArray and a set of useful methods and functions for working with the array. The internal backing storage is bytearray, array.array or list depending on type of input.

class TypedArray(initializer: Iterable[_TSource] | None = None, typecode: TypeCode | None = None)
choose(chooser: Callable[[_TSource], Option[_TResult]]) → TypedArray[_TResult]
Choose items from the list.

Applies the given function to each element of the list. Returns the list comprised of the results x for each element where the function returns Some(x).

Parameters
:
chooser – The function to generate options from the elements.

Returns
:
The list comprising the values selected from the chooser function.

classmethod empty() → TypedArray[Any]
Returns empty array.

filter(predicate: Callable[[_TSource], bool]) → TypedArray[_TSource]
Filter list.

Returns a new collection containing only the elements of the collection for which the given predicate returns True.

Parameters
:
predicate – The function to test the input elements.

Returns
:
A list containing only the elements that satisfy the predicate.

fold(folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold array.

Applies a function to each element of the array, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Return the final result. If the input function is f and the elements are i0…iN then computes f (… (f s i0) i1 …) iN.

Parameters
:
folder – The function to update the state given the input elements.

state – The initial state.

Returns
:
Partially applied fold function that takes the source list and returns the final state value.

forall(predicate: Callable[[_TSource], bool]) → bool
Test all elements.

Tests if all elements of the collection satisfy the given predicate.

Parameters
:
predicate – The function to test the input elements.

Returns
:
True if all of the elements satisfy the predicate.

head() → _TSource
Returns the first element of the list.

Parameters
:
source – The input list.

Returns
:
The first element of the list.

Raises
:
ValueError – Thrown when the list is empty.

indexed(start: int = 0) → TypedArray[tuple[int, _TSource]]
Index array elements.

Returns a new array whose elements are the corresponding elements of the input array paired with the index (from start) of each element.

Parameters
:
start – Optional index to start from. Defaults to 0.

Returns
:
The list of indexed elements.

insert(index: int, value: _TSource) → None
S.insert(index, value) – insert value before index

is_empty() → bool
Return True if list is empty.

item(index: int) → _TSource
Indexes into the list. The first element has index 0.

Parameters
:
index – The index to retrieve.

Returns
:
The value at the given index.

static of(*args: _TSource) → TypedArray[_TSource]
Create list from a number of arguments.

static of_seq(xs: Iterable[_TSource]) → TypedArray[_TSource]
Create list from iterable sequence.

skip(count: int) → TypedArray[_TSource]
Returns the array after removing the first N elements.

Parameters
:
count – The number of elements to skip.

Returns
:
The array after removing the first N elements.

sort(reverse: bool = False) → TypedArray[_TSourceSortable]
Sort array directly.

Returns a new sorted collection.

Parameters
:
reverse – Sort in reversed order.

Returns
:
A sorted array.

sort_with(func: Callable[[_TSource], Any], reverse: bool = False) → TypedArray[_TSource]
Sort array with supplied function.

Returns a new sorted collection.

Parameters
:
func – The function to extract a comparison key from each element in list.

reverse – Sort in reversed order.

Returns
:
A sorted array.

tail() → TypedArray[_TSource]
Return tail of List.

take(count: int) → TypedArray[_TSource]
Returns the first N elements of the list.

Parameters
:
count – The number of items to take.

Returns
:
The result list.

take_last(count: int) → TypedArray[_TSource]
Take last elements.

Returns a specified number of contiguous elements from the end of the list.

Parameters
:
count – The number of items to take.

Returns
:
The result list.

try_head() → Option[_TSource]
Try to return first element.

Returns the first element of the list, or None if the list is empty.

static unfold(generator: Callable[[_TState], Option[tuple[_TSource, _TState]]], state: _TState) → TypedArray[_TSource]
Unfold array.

Returns a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

state – The initial state.

Returns
:
The result list.

filter(source: TypedArray[_TSource], predicate: Callable[[_TSource], bool]) → TypedArray[_TSource]
Filter array.

Returns a new array containing only the elements of the array for which the given predicate returns True.

Parameters
:
source – The source array to filter.

predicate – The function to test the input elements.

Returns
:
Partially applied filter function.

fold(source: TypedArray[_TSource], folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold the array.

Applies a function to each element of the collection, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Return the final result. If the input function is f and the elements are i0…iN then computes f (… (f s i0) i1 …) iN.

Parameters
:
source – The source array to fold.

folder – The function to update the state given the input elements.

state – The initial state.

Returns
:
Partially applied fold function that takes the source list and returns the final state value.

is_empty(source: TypedArray[Any]) → bool
Returns True if the list is empty, False otherwise.

map(source: TypedArray[_TSource], mapper: Callable[[_TSource], _TResult]) → TypedArray[_TResult]
Map array.

Builds a new array whose elements are the results of applying the given function to each of the elements of the array.

Parameters
:
source – The source array to map.

mapper – The function to transform elements from the input array.

Returns
:
A new array of transformed elements.

of(*args: _TSource) → TypedArray[_TSource]
Create list from a number of arguments.

of_seq(xs: Iterable[_TSource]) → TypedArray[_TSource]
Create list from iterable sequence.

take(source: TypedArray[_TSource], count: int) → TypedArray[_TSource]
Return the first N elements of the array.

Parameters
:
source – The source array to take from.

count – The number of items to take.

Returns
:
The result array.

take_last(source: TypedArray[_TSource], count: int) → TypedArray[_TSource]
Take last elements.

Returns a specified number of contiguous elements from the end of the list.

Parameters
:
source – The source array to take from.

count – The number of items to take.

Returns
:
The result list.

try_head(source: TypedArray[_TSource]) → Option[_TSource]
Try to get the first element from the list.

Returns the first element of the list, or None if the list is empty.

Parameters
:
source – The input list.

Returns
:
The first element of the list or Nothing.

unfold(state: _TState, generator: Callable[[_TState], Option[tuple[_TSource, _TState]]]) → TypedArray[_TSource]
Unfold array.

Returns a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
state – The initial state.

generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

Returns
:
The result list.

```

# Map


```

class Map(_Map__tree: Option[MapTreeLeaf[_Key, _Value]] | None = None)
The immutable map class.

for_all(predicate: Callable[[_Key, _Value], bool]) → bool
Test all elements in map.

Returns true if the given predicate returns true for all of the bindings in the map.

Parameters
:
predicate – The function to test the input elements.

Returns
:
True if the predicate evaluates to true for all of the bindings in the map.

items() → a set-like object providing a view on D's items
map(mapping: Callable[[_Key, _Value], _Result]) → Map[_Key, _Result]
Map the mapping.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The key passed to the function indicates the key of element being transformed.

Parameters
:
mapping – The function to transform the key/value pairs

Returns
:
The resulting map of keys and transformed values.

static of_block(lst: Block[tuple[_Key, _Value]]) → Map[_Key, _Value]
Generate map from list.

Returns
:
The new map.

static of_list(lst: list[tuple[_Key_, _Result]]) → Map[_Key_, _Result]
Generate map from list.

Returns
:
The new map.

static of_seq(sequence: Iterable[tuple[_Key_, _Result]]) → Map[_Key_, _Result]
Generate map from sequence.

Generates a new map from an iterable of key/value tuples. This is an alias for Map.create.

Returns
:
The new map.

to_seq() → Iterable[tuple[_Key, _Value]]
Convert to sequence.

Returns
:
Sequence of key, value tuples.

add(table: Map[_Key, _Value], key: _Key, value: _Value) → Map[_Key, _Value]
Add key with value to map.

Returns a new map with the binding added to the given map. If a binding with the given key already exists in the input map, the existing binding is replaced by the new binding in the result map.

Parameters
:
table – The input map.

key – The input key.

value – The input value.

Returns
:
A partially applied add function that takes the input map and returns the output map.

change(table: Map[_Key, _Value], key: _Key, fn: Callable[[Option[_Value]], Option[_Value]]) → Map[_Key, _Value]
Change element in map.

Returns a new map with the value stored under key changed according to f.

Parameters
:
key – The input key.

fn – The change function.

table – The input table.

Returns
:
The input key.

count(table: Map[Any, Any]) → int
Return the number of bindings in the map.

exists(table: Map[_Key, _Value], predicate: Callable[[_Key, _Value], bool]) → bool
Test if element exists in map.

Returns true if the given predicate returns true for one of the bindings in the map.

Parameters
:
table – The input map.

predicate – The function to test the input elements.

Returns
:
Partially applied function that takes a map table and returns true if the predicate returns true for one of the key/value pairs.

find(table: Map[_Key, _Value], key: _Key) → _Value
Find element with key in map.

Lookup an element in the map, raising KeyNotFoundException if no binding exists in the map.

Parameters
:
key – The key to find.

table – The map to find the key in.

is_empty(table: Map[Any, Any]) → bool
Is the map empty?

Parameters
:
table – The input map.

Returns
:
True if the map is empty.

of(**args: _Value) → Map[str, _Value]
Create map from arguments.

remove(table: Map[_Key, _Value], key: _Key) → Map[_Key, _Value]
Remove element from map.

Removes an element from the domain of the map. No exception is raised if the element is not present.

Parameters
:
key – The key to remove.

table – The table to remove the key from.

Returns
:
The resulting map.

try_find(table: Map[_Key, _Value], key: _Key) → Option[_Value]
Try to find element with key in map.

Lookup an element in the map, returning a Some value if the element is in the domain of the map and Nothing if not.

Parameters
:
table – The input map.

key – The input key.

Returns
:
A partially applied try_find function that takes a map instance and returns the result.

try_pick(table: Map[_Key, _Value], chooser: Callable[[_Key, _Value], Option[_Result]]) → Option[_Result]
Pick element in map.

Searches the map looking for the first element where the given function returns a Some value.

Parameters
:
table – The input map.

chooser – The function to generate options from the key/value pairs.

Returns
:
Partially applied try_pick function that takes the input map and returns the first result.

```


# Block

```

Block
A frozen immutable list module.

This module provides an immutable list type Block and a set of useful methods and functions for working with the list.

Named “Block” to avoid conflicts with the builtin Python List type.

A Block is actually backed by a Python tuple. Tuples in Python are immutable and gives us a high performant implementation of immutable lists.

Example

xs = block.of_list([1, 2, 3, 4, 5])
ys = block.empty.cons(1).cons(2).cons(3).cons(4).cons(5)
zs = pipe(
    xs,
    block.filter(lambda x: x<10)
)
class Block(value: Iterable[_TSource] = ())
Immutable list type.

Is faster than List for prepending, but slower for appending.

Count: 200K:

| Operation | Block      | List   |
|-----------|------------|--------|
| Append    | 3.29 s     | 0.02 s |
| Prepend   | 0.05 s     | 7.02 s |
Example

xs = Cons(5, Cons(4, Cons(3, Cons(2, Cons(1, Nil)))))
ys = empty.cons(1).cons(2).cons(3).cons(4).cons(5)
append(other: Block[_TSource]) → Block[_TSource]
Append other block to end of the block.

choose(chooser: Callable[[_TSource], Option[_TResult]]) → Block[_TResult]
Choose items from the list.

Applies the given function to each element of the list. Returns the list comprised of the results x for each element where the function returns Some(x).

Parameters
:
chooser – The function to generate options from the elements.

Returns
:
The list comprising the values selected from the chooser function.

collect(mapping: Callable[[_TSource], Block[_TResult]]) → Block[_TResult]
Collect items from the list.

Applies the given function to each element of the list and concatenates all the resulting sequences. This function is known as bind or flat_map in other languages.

Parameters
:
mapping – The function to generate sequences from the elements.

Returns
:
A list comprising the concatenated values from the mapping function.

cons(element: _TSource) → Block[_TSource]
Add element to front of list.

dict() → list[_TSource]
Returns a json serializable representation of the list.

static empty() → Block[Any]
Returns empty list.

filter(predicate: Callable[[_TSource], bool]) → Block[_TSource]
Filter list.

Returns a new collection containing only the elements of the collection for which the given predicate returns True.

Parameters
:
predicate – The function to test the input elements.

Returns
:
A list containing only the elements that satisfy the predicate.

fold(folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold block.

Applies a function to each element of the collection, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Return the final result. If the input function is f and the elements are i0…iN then computes f (… (f s i0) i1 …) iN.

Parameters
:
folder – The function to update the state given the input elements.

state – The initial state.

Returns
:
Partially applied fold function that takes the source list and returns the final state value.

forall(predicate: Callable[[_TSource], bool]) → bool
For all elements in block.

Tests if all elements of the collection satisfy the given predicate.

Parameters
:
predicate – The function to test the input elements.

Returns
:
True if all of the elements satisfy the predicate.

head() → _TSource
Returns the first element of the list.

Parameters
:
source – The input list.

Returns
:
The first element of the list.

Raises
:
ValueError – Thrown when the list is empty.

indexed(start: int = 0) → Block[tuple[int, _TSource]]
Index elements in block.

Returns a new list whose elements are the corresponding elements of the input list paired with the index (from start) of each element.

Parameters
:
start – Optional index to start from. Defaults to 0.

Returns
:
The list of indexed elements.

is_empty() → bool
Return True if list is empty.

item(index: int) → _TSource
Indexes into the list. The first element has index 0.

Parameters
:
index – The index to retrieve.

Returns
:
The value at the given index.

map(mapping: Callable[[_TSource], _TResult]) → Block[_TResult]
Map list.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection.

Parameters
:
mapping – The function to transform elements from the input list.

Returns
:
The list of transformed elements.

mapi(mapping: Callable[[int, _TSource], _TResult]) → Block[_TResult]
Map list with index.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

Parameters
:
mapping – The function to transform elements and their indices.

Returns
:
The list of transformed elements.

static of(*args: _TSource) → Block[_TSource]
Create list from a number of arguments.

static of_seq(xs: Iterable[_TResult]) → Block[_TResult]
Create list from iterable sequence.

partition(predicate: Callable[[_TSource], bool]) → tuple[Block[_TSource], Block[_TSource]]
Partition block.

Splits the collection into two collections, containing the elements for which the given predicate returns True and False respectively. Element order is preserved in both of the created lists.

Parameters
:
predicate – The function to test the input elements.

Returns
:
A list containing the elements for which the predicate evaluated to true and a list containing the elements for which the predicate evaluated to false.

reduce(reduction: Callable[[_TSource, _TSource], _TSource]) → _TSource
Reduce block.

Apply a function to each element of the collection, threading an accumulator argument through the computation. Apply the function to the first two elements of the list. Then feed this result into the function along with the third element and so on. Return the final result. If the input function is f and the elements are i0…iN then computes f (… (f i0 i1) i2 …) iN.

Parameters
:
reduction – The function to reduce two list elements to a

element. (single)

Returns
:
Returns the final state value.

skip(count: int) → Block[_TSource]
Returns the list after removing the first N elements.

Parameters
:
count – The number of elements to skip.

Returns
:
The list after removing the first N elements.

sort(reverse: bool = False) → Block[_TSourceSortable]
Sort list directly.

Returns a new sorted collection.

Parameters
:
reverse – Sort in reversed order.

Returns
:
A sorted list.

sort_with(func: Callable[[_TSource], Any], reverse: bool = False) → Block[_TSource]
Sort list with supplied function.

Returns a new sorted collection.

Parameters
:
func – The function to extract a comparison key from each element in list.

reverse – Sort in reversed order.

Returns
:
A sorted list.

starmap(mapping: Callable[[Unpack], _TResult]) → Block[_TResult]
Starmap source sequence.

Unpack arguments grouped as tuple elements. Builds a new collection whose elements are the results of applying the given function to the unpacked arguments to each of the elements of the collection.

Parameters
:
mapping – A function to transform items from the input sequence.

Returns
:
Partially applied map function.

tail() → Block[_TSource]
Return tail of List.

take(count: int) → Block[_TSource]
Returns the first N elements of the list.

Parameters
:
count – The number of items to take.

Returns
:
The result list.

take_last(count: int) → Block[_TSource]
Take last elements from block.

Returns a specified number of contiguous elements from the end of the list.

Parameters
:
count – The number of items to take.

Returns
:
The result list.

try_head() → Option[_TSource]
Try to get head of block.

Returns the first element of the list, or None if the list is empty.

static unfold(generator: Callable[[_TState], Option[tuple[_TSource, _TState]]], state: _TState) → Block[_TSource]
Unfold block.

Returns a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

state – The initial state.

Returns
:
The result list.

zip(other: Block[_TResult]) → Block[tuple[_TSource, _TResult]]
Zip block.

Combines the two lists into a list of pairs. The two lists must have equal lengths. .

Parameters
:
other – The second input list.

Returns
:
A single list containing pairs of matching elements from the input lists.

collect(source: Block[_TSource], mapping: Callable[[_TSource], Block[_TResult]]) → Block[_TResult]
Collect items from the list.

Applies the given function to each element of the list and concatenates all the resulting sequences. This function is known as bind or flat_map in other languages.

Parameters
:
source – The input list (curried flipped).

mapping – The function to generate sequences from the elements.

Returns
:
A sequence comprising the concatenated values from the mapping function.

concat(sources: Iterable[Block[_TSource]]) → Block[_TSource]
Concatenate sequence of Block’s.

empty: Block[Any] = []
The empty list.

filter(source: Block[_TSource], predicate: Callable[[_TSource], bool]) → Block[_TSource]
Filter elements in block.

Returns a new collection containing only the elements of the collection for which the given predicate returns True.

Parameters
:
source – The input block to filter.

predicate – The function to test the input elements.

Returns
:
Partially applied filter function.

fold(source: Block[_TSource], folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold elements in block.

Applies a function to each element of the collection, threading an accumulator argument through the computation. Take the second argument, and apply the function to it and the first element of the list. Then feed this result into the function along with the second element and so on. Return the final result. If the input function is f and the elements are i0…iN then computes f (… (f s i0) i1 …) iN.

Parameters
:
source – The input block to fold.

folder – The function to update the state given the input elements.

state – The initial state.

Returns
:
Partially applied fold function that takes the source list and returns the final state value.

head(source: Block[_TSource]) → _TSource
Returns the first element of the list.

Parameters
:
source – The input list.

Returns
:
The first element of the list.

Raises
:
ValueError – Thrown when the list is empty.

indexed(source: Block[_TSource]) → Block[tuple[int, _TSource]]
Index elements in block.

Returns a new list whose elements are the corresponding elements of the input list paired with the index (from 0) of each element.

Returns
:
The list of indexed elements.

is_empty(source: Block[Any]) → bool
Returns True if the list is empty, False otherwise.

item(source: Block[_TSource], index: int) → _TSource
Indexes into the list. The first element has index 0.

Parameters
:
source – The input block list.

index – The index to retrieve.

Returns
:
The value at the given index.

map(source: Block[_TSource], mapper: Callable[[_TSource], _TResult]) → Block[_TResult]
Map list.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection.

Parameters
:
source – The input list (curried flipped).

mapper – The function to transform elements from the input list.

Returns
:
The list of transformed elements.

mapi(source: Block[_TSource], mapper: Callable[[int, _TSource], _TResult]) → Block[_TResult]
Map list with index.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

Parameters
:
source – The source block to map

mapper – The function to transform elements and their indices.

Returns
:
The list of transformed elements.

of_seq(xs: Iterable[_TSource]) → Block[_TSource]
Create list from iterable sequence.

partition(source: Block[_TSource], predicate: Callable[[_TSource], bool]) → tuple[Block[_TSource], Block[_TSource]]
Partition block.

Splits the collection into two collections, containing the elements for which the given predicate returns True and False respectively. Element order is preserved in both of the created lists.

Parameters
:
source – The source block to partition (curried flipped)

predicate – The function to test the input elements.

Returns
:
A list containing the elements for which the predicate evaluated to true and a list containing the elements for which the predicate evaluated to false.

skip(source: Block[_TSource], count: int) → Block[_TSource]
Returns the list after removing the first N elements.

Parameters
:
source – Source block to skip elements from.

count – The number of elements to skip.

Returns
:
The list after removing the first N elements.

skip_last(source: Block[_TSource], count: int) → Block[_TSource]
Returns the list after removing the last N elements.

Parameters
:
source – The source block to skip from.

count – The number of elements to skip.

Returns
:
The list after removing the last N elements.

sort(source: Block[_TSourceSortable], reverse: bool = False) → Block[_TSourceSortable]
Returns a new sorted collection.

Parameters
:
source – The source block to sort.

reverse – Sort in reversed order.

Returns
:
Partially applied sort function.

sort_with(source: Block[_TSource], func: Callable[[_TSource], Any], reverse: bool = False) → Block[_TSource]
Returns a new collection sorted using “func” key function.

Parameters
:
source – The source block to sort.

func – The function to extract a comparison key from each element in list.

reverse – Sort in reversed order.

Returns
:
Partially applied sort function.

take(source: Block[_TSource], count: int) → Block[_TSource]
Returns the first N elements of the list.

Parameters
:
source – The input blcok to take elements from.

count – The number of items to take.

Returns
:
The result list.

take_last(source: Block[_TSource], count: int) → Block[_TSource]
Take last elements from block.

Returns a specified number of contiguous elements from the end of the list.

Parameters
:
source – The input block to take elements from.

count – The number of items to take.

Returns
:
The result list.

try_head(source: Block[_TSource]) → Option[_TSource]
Try to get the first element from the list.

Returns the first element of the list, or None if the list is empty.

Parameters
:
source – The input list.

Returns
:
The first element of the list or Nothing.

unfold(state: _TState, generator: Callable[[_TState], Option[tuple[_TSource, _TState]]]) → Block[_TSource]
Unfold block.

Returns a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

state – The initial state.

Returns
:
The result list.

zip(source: Block[_TSource], other: Block[_TResult]) → Block[tuple[_TSource, _TResult]]
Zip block with other.

Combines the two lists into a list of pairs. The two lists must have equal lengths.

Parameters
:
source – The input block to zip with other.

other – The second input list.

Returns
:
Paritally applied zip function that takes the source list and returns s single list containing pairs of matching elements from the input lists.

Reach
```

# Seq

```
Sequence module.

Contains a collection of static methods (functions) for operating on sequences. A sequence is a thin wrapper around Iterable so all functions take (and return) Python iterables.

All functions takes the source as the last curried argument, i.e all functions returns a function that takes the source sequence as the only argument.

Example (functional style):
from expression.collections import seq
xs = seq.of_iterable([1, 2, 3])
ys = xs.pipe(
    seq.map(lambda x: x + 1),
    seq.filter(lambda x: x < 3)
)
Example (fluent style):
from expression.collections import Seq
xs = Seq([1, 2, 3])
ys = xs.map(lambda x: x + 1).filter(lambda x: x < 3)
class Seq(iterable: Iterable[_TSource] = ())
Sequence type.

Contains instance methods for dot-chaining operators methods on sequences.

Example

xs = Seq([1, 2, 3])
ys = xs.map(lambda x: x + 1).filter(lambda x: x < 3)
append(*others: Iterable[_TSource]) → Seq[_TSource]
Append sequence to other sequences.

Wraps the given enumerations as a single concatenated enumeration.

choose(chooser: Callable[[_TSource], Option[_TResult]]) → Seq[_TResult]
Choose items from the sequence.

Applies the given function to each element of the list. Returns the list comprised of the results x for each element where the function returns Some(x).

Parameters
:
chooser – The function to generate options from the elements.

Returns
:
The list comprising the values selected from the chooser function.

collect(mapping: Callable[[_TSource], Seq[_TResult]]) → Seq[_TResult]
Collect items from the sequence.

Applies the given function to each element of the list and concatenates all the resulting sequences. This function is known as bind or flat_map in other languages.

Parameters
:
mapping – The function to generate sequences from the elements.

Returns
:
A sequence comprising the concatenated values from the mapping function.

static delay(generator: Callable[[], Iterable[_TSource]]) → Iterable[_TSource]
Delay sequence.

Returns a sequence that is built from the given delayed specification of a sequence.

The input function is evaluated each time an IEnumerator for the sequence is requested.

Parameters
:
generator – The generating function for the sequence.

dict() → Iterable[_TSource]
Returns a json serializable representation of the list.

static empty() → Seq[Any]
Returns empty sequence.

fold(folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold sequence.

Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0…iN then computes f (… (f s i0)…) iN.

Parameters
:
folder – A function that updates the state with each element from the sequence.

state – The initial state.

Returns
:
The state object after the folding function is applied to each element of the sequence.

head() → _TSource
Returns the first element of the sequence.

length() → int
Returns the length of the sequence.

map(mapper: Callable[[_TSource], _TResult]) → Seq[_TResult]
Map sequence.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection.

Parameters
:
mapper – A function to transform items from the input sequence.

Returns
:
The result sequence.

mapi(mapping: Callable[[int, _TSource], _TResult]) → Seq[_TResult]
Map list with index.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

Parameters
:
mapping – The function to transform elements and their indices.

Returns
:
The list of transformed elements.

scan(scanner: Callable[[_TState, _TSource], _TState], state: _TState) → Iterable[_TState]
Scan sequence.

Like fold, but computes on-demand and returns the sequence of intermediary and final results.

Parameters
:
scanner – A function that updates the state with each element from the sequence.

state – The initial state.

Returns
:
The resulting sequence of computed states.

skip(count: int) → Seq[_TSource]
Skip elements from sequence.

Returns a sequence that skips N elements of the underlying sequence and then yields the remaining elements of the sequence.

Parameters
:
count – The number of items to skip.

starmap(mapping: Callable[[_T1, _T2], _TResult]) → Seq[_TResult]
starmap(mapping: Callable[[_T1, _T2, _T3], _TResult]) → Seq[_TResult]
starmap(mapping: Callable[[_T1, _T2, _T3, _T4], _TResult]) → Seq[_TResult]
Starmap source sequence.

Unpack arguments grouped as tuple elements. Builds a new collection whose elements are the results of applying the given function to the unpacked arguments to each of the elements of the collection.

Parameters
:
mapping – A function to transform items from the input sequence.

Returns
:
Partially applied map function.

sum() → _TSupportsSum
Returns the sum of the elements in the sequence.

sum_by(projection: Callable[[_TSource], _TSupportsSum]) → _TSupportsSum
Sum the sequence by projection.

Returns the sum of the results generated by applying the function to each element of the sequence.

tail() → Seq[_TSource]
Return the tail of the sequence.

Returns a sequence that skips 1 element of the underlying sequence and then yields the remaining elements of the sequence.

take(count: int) → Seq[_TSource]
Returns the first N elements of the sequence.

Parameters
:
count – The number of items to take.

classmethod unfold(generator: Callable[[_TState], Option[tuple[_TSource, _TState]]], state: _TState) → Iterable[_TSource]
Unfold sequence.

Returns a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

state – The initial state.

Returns
:
The result list.

zip(other: Iterable[_TResult]) → Iterable[tuple[_TSource, _TResult]]
Zip sequence.

Combines the two sequences into a list of pairs. The two sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.

Parameters
:
other – The second input sequence.

Returns
:
The result sequence.

append(*others: Iterable[_TSource]) → Callable[[Iterable[_TSource]], Iterable[_TSource]]
Append sequence to other sequences.

Wraps the given enumerations as a single concatenated enumeration.

choose(source: Iterable[_TSource], chooser: Callable[[_TSource], Option[_TResult]]) → Iterable[_TResult]
Choose items from the sequence.

Applies the given function to each element of the list. Returns the list comprised of the results x for each element where the function returns Some(x).

Parameters
:
source – The input sequence to to choose from.

chooser – The function to generate options from the elements.

Returns
:
The list comprising the values selected from the chooser function.

collect(source: Iterable[_TSource], mapping: Callable[[_TSource], Iterable[_TResult]]) → Iterable[_TResult]
Collect items from the sequence.

Applies the given function to each element of the list and concatenates all the resulting sequences. This function is known as bind or flat_map in other languages.

Parameters
:
source – The input sequence to to collect from.

mapping – The function to generate sequences from the elements.

Returns
:
A sequence comprising the concatenated values from the mapping function.

concat(*iterables: Iterable[_TSource]) → Iterable[_TSource]
Concatenate sequences.

Combines the given variable number of enumerations and/or enumeration-of-enumerations as a single concatenated enumeration.

Parameters
:
iterables – The input enumeration-of-enumerations.

Returns
:
The result sequence.

delay(generator: Callable[[], Iterable[_TSource]]) → Iterable[_TSource]
Delay sequence.

Returns a sequence that is built from the given delayed specification of a sequence.

The input function is evaluated each time an Iterator for the sequence is requested.

Parameters
:
generator – The generating function for the sequence.

empty: Seq[Any] = []
The empty sequence.

filter(source: Iterable[_TSource], predicate: Callable[[_TSource], bool]) → Iterable[_TSource]
Filter sequence.

Filters the sequence to a new sequence containing only the elements of the sequence for which the given predicate returns True.

Parameters
:
source – (curried) The input sequence to to filter.

predicate – A function to test whether each item in the input sequence should be included in the output.

Returns
:
A partially applied filter function.

fold(source: Iterable[_TSource], folder: Callable[[_TState, _TSource], _TState], state: _TState) → _TState
Fold elements in sequence.

Applies a function to each element of the collection, threading an accumulator argument through the computation. If the input function is f and the elements are i0…iN then computes f (… (f s i0)…) iN.

Parameters
:
source – The input sequence to fold.

folder – A function that updates the state with each element from the sequence.

state – The initial state.

Returns
:
Partially applied fold function that takes a source sequence and returns the state object after the folding function is applied to each element of the sequence.

fold_back(folder: Callable[[_TSource, _TState], _TState], source: Iterable[_TSource]) → Callable[[_TState], _TState]
Fold elements in sequence backwards.

Applies a function to each element of the collection, starting from the end, threading an accumulator argument through the computation. If the input function is f and the elements are i0…iN then computes f i0 (… (f iN s)…).

Parameters
:
folder – A function that updates the state with each element from the sequence.

source – The input sequence to fold backwards.

Returns
:
Partially applied fold_back function.

head(source: Iterable[_TSource]) → _TSource
Return the first element of the sequence.

Parameters
:
source – The input sequence.

Returns
:
The first element of the sequence.

Raises
:
Raises ValueError if the source sequence is empty. –

iter(source: Iterable[_TSource], action: Callable[[_TSource], None]) → None
Applies the given function to each element of the collection.

Parameters
:
source – The input sequence to iterate.

action – A function to apply to each element of the sequence.

Returns
:
A partially applied iter function.

map(source: Iterable[_TSource], mapper: Callable[[_TSource], _TResult]) → Iterable[_TResult]
Map source sequence.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection.

Parameters
:
source – The input sequence to map.

mapper – A function to transform items from the input sequence.

Returns
:
Partially applied map function.

mapi(source: Iterable[_TSource], mapping: Callable[[int, _TSource], _TResult]) → Iterable[_TResult]
Map list with index.

Builds a new collection whose elements are the results of applying the given function to each of the elements of the collection. The integer index passed to the function indicates the index (from 0) of element being transformed.

Parameters
:
source – The input sequence to to map.

mapping – The function to transform elements and their indices.

Returns
:
The list of transformed elements.

max(source: Iterable[_TSupportsGreaterThan]) → _TSupportsGreaterThan
Return maximum of all elements.

Returns the greatest of all elements of the sequence, compared via max().

min(source: Iterable[_TSupportsLessThan]) → _TSupportsLessThan
Return the minimum of all elements.

Returns the smallest of all elements of the sequence, compared via max().

of(*args: _TSource) → Seq[_TSource]
Create sequence from iterable.

Enables fluent dot chaining on the created sequence object.

of_iterable(source: Iterable[_TSource]) → Seq[_TSource]
Alias to Seq.of.

of_list(source: Iterable[_TSource]) → Seq[_TSource]
Alias to seq.of_iterable.

scan(source: Iterable[_TSource], scanner: Callable[[_TState, _TSource], _TState], state: _TState) → Iterable[_TState]
Scan elements in sequence.

Like fold, but computes on-demand and returns the sequence of intermediary and final results.

Parameters
:
source – The input sequence.

scanner – A function that updates the state with each element

state – The initial state.

singleton(item: _TSource) → Seq[_TSource]
Returns a sequence that yields one item only.

Parameters
:
item – The input item.

Returns
:
The result sequence of one item.

skip(source: Iterable[_TSource], count: int) → Iterable[_TSource]
Skip elements from sequence.

Returns a sequence that skips N elements of the underlying sequence and then yields the remaining elements of the sequence.

Parameters
:
source – The input sequence.

count – The number of items to skip.

sum(source: Iterable[_TSupportsSum]) → _TSupportsSum
Returns the sum of the elements in the sequence.

sum_by(source: Iterable[_TSource], projection: Callable[[_TSource], _TSupportsSum]) → _TSupportsSum
Sum all elements in sequence.

Returns the sum of the results generated by applying the function to each element of the sequence.

tail(source: Iterable[_TSource]) → Iterable[_TSource]
Return tail of sequence.

Returns a sequence that skips 1 element of the underlying sequence and then yields the remaining elements of the sequence.

take(source: Iterable[_TSource], count: int) → Iterable[_TSource]
Returns the first N elements of the sequence.

Parameters
:
source – The source sequence.

count – The number of items to take.

Returns
:
The result sequence.

unfold(state: _TState, generator: Callable[[_TState], Option[tuple[_TSource, _TState]]]) → Iterable[_TSource]
Unfold sequence.

Generates a list that contains the elements generated by the given computation. The given initial state argument is passed to the element generator.

Parameters
:
state – The initial state.

generator – A function that takes in the current state and returns an option tuple of the next element of the list and the next state value.

Returns
:
A partially applied unfold function that takes the state and returns the result list.

zip(source1: Iterable[_TSource]) → Callable[[Iterable[_TResult]], Iterable[tuple[_TSource, _TResult]]]
Zip sequence with other.

Combines the two sequences into a list of pairs. The two sequences need not have equal lengths: when one sequence is exhausted any remaining elements in the other sequence are ignored.

Parameters
:
source1 – The first input sequence.

Returns
:
Partially applied zip function.


```
